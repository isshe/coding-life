
# 初始化
记录一些初始化的信息。
> 由于是根据《深入理解Linux网络技术内幕》学习，因此相关设备是"网络设备"，不过相关流程应该具有一定通用性。

注册和初始化的任务一部分由内核完成，一部分由设备驱动程序完成。主要分为以下几个阶段：
* 硬件初始化
* 软件初始化
* 功能初始化

设备与内核交互方式：
* 轮询（polling）：由内核端驱动。
* 中断（interrupt）：由设备端驱动。

## 1.资源分配
设备驱动程序与内核通信的资源：
* IRQ线：设备用中断来通知内核一些事情。
    * 虚拟设备不需要分派一个IRQ，如回环设备。
    * 每个中断事件都会运行一个中断处理例程(interrupt handler)。
    * 相关函数：request_irq()/free_irq()
* I/O端口和内存注册：通常是将设备内存映射到系统内存，以方便读写。
    * 相关函数：request_region()/release_region()

## 2.虚拟设备分类
* 绑定（bonding）：绑定一组物理设备，使其如同单一设备。
* 802.1Q: 以VLAN报头扩充802.3/Ethernet帧头，因而得以建立VLAN。
* 桥接（bridging）：网桥的虚拟代表。
* 别名接口(aliasing interface): 支持单物理接口多IP。（现在代码改进，不用这个也能实现多IP）
* 普通均衡器（true equalizer, TEQL）: 这是队列规则，用于流量控制。其实现需要建立一个特殊设备。TEQL背后的思想有点类似Bonding。
* 隧道接口（tunnel interface）：IP-over-IP(IPIP)隧道以及GRE（Generalized Routing Encapsulation，通用路由封装）协议的实现基础是虚拟设备的建立。


### 3.参数分析(parse_arg)->两遍分析
内核为了兼容性，保留了两种关键字处理模型。先用新的对关键字进行处理，无法识别时，再用旧型基础架构予以处理。
再不能识别，则关键字和其值就会传给init进程。init内核线程结束时会通过`run_init_process`进行处理。
引导字符串的解析以及处理函数的调用分成两遍进行：
* 第一遍，只看必须在处理处理的较高优先级的选项，由一个特殊的表示(early)识别。
* 第二遍，负责所有其他选项。多数选项都属于这一类。旧模型的所有选项都会在这一遍处理。

新和旧的选项会放在两个不同的内存区域：
* `__setup_start...__setup_end`: 引导阶段结束后就会释放。
    * 所有旧的选项，无论是否设置`early`，都会放在这个区域。
* `__start___param...__stop___param`：不会释放，其内容会输出到/sys，使得这些选项可以展露给用户。


### 4. 引导期间初始化宏
相关宏会把相关函数放到相应的内存区域。
* `__init`宏：把相关函数放到`.text.init`内存节区。
    * 由`free_initmem`函数释放。
* `__exit`宏：把相关函数放到`.text.exit`内存节区。
    * 内建在内核的模块，这个节区可以在链接期间直接丢弃。（有些体系结构在运行时才丢，以应付`交叉引用`）
* `xxx_initcall`: 把相关函数放在`.initcall.xx.init`内存节区。
    * 由`free_initmem`函数释放。
* `__exitcall`: 把相关函数放到`.exitcall.exit`内存节区。

大多数初始化函数的属性
* 当所有内核组件都已初始化时，必须在引导期间执行。【？？？】
* 一旦被执行后，就不再需要这些函数了。

### 5. 内存最优化
与用户空间不同的是，内核空间代码及数据会永久驻留在内存中，所以采取各种可能的方式减少内存浪费是很重要的。
初始化代码就是内存最优化的理想对象：
* 当相关联的模块加载时，module_init函数只会执行一次。
    * 当该模块与内核静态链接时，在引导期间，module_init函数执行后，内核就可将其释放掉。
* 当相关联的模块与内核静态链接时，module_exit函数根本不会执行。因此，没有必要吧module_exit函数引入到内核映像中。
以上两个分别是`运行最优化`和`链接最优化`。
相关函数是：`free_init_mem`。


