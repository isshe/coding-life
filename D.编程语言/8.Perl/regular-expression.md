正则表达式
---

# 三种形式

匹配：`m/<regexp>;/` （还可以简写为 `/<regexp>;/` ，略去 `m`）

替换：`s/<pattern>;/<replacement>;/`

转化：`tr/<pattern>;/<replacemnt>;/`

# 八大原则

* 原则1：正则表达式有三种不同形式(匹配`m/ /`，替换`s/ / /eg`和转换`tr/ / /`)。
* 原则2：正则表达式仅对标量进行匹配( `$scalar =~ m/a/`; 可以工作; `@array =~ m/a/` 将把@array作为标量对待，因此可能不会成功)。
* 原则3：正则表达式匹配一个给定模式的最早的可能匹配。缺省时，仅匹配或替换正则表达式一次( `$a = 'string string2'; $a =~ s/string/ /; 导致 $a = 'string 2'`)。
* 原则4：正则表达式能够处理双引号所能处理的任意和全部字符( `$a =~ m/$varb/` 在匹配前把 `varb` 扩展为变量；如果 `$varb = 'a' $a = 'as'，$a =~ s/$varb/ /`; 等价于 `$a =~ s/a/ /; `，执行结果使 `$a = " s" `)。
* 原则5：正则表达式在求值过程中产生两种情况：结果状态和反向引用： `$a=~ m/pattern/` 表示 `$a` 中是否有子串 `pattern` 出现，`$a =~ s/(word1)(word2)/$2$1/` 则“调换”这两个单词。
* 原则6：正则表达式的核心能力在于通配符和多重匹配运算符以及它们如何操作。`$a =~ m/\w+/` 匹配一个或多个单词字符；`$a =~ m/\d*/` 匹配零个或多个数字。
* 原则7：如果欲匹配不止一个字符集合，Perl使用 `|` 来增加灵活性。如果输入 `m/(cat|dog)/` 则相当于匹配字符串 `cat` 或者 `dog`。
* 原则8：Perl用 `(?..)`、`(?=..)`、`(?!..)`语法给正则表达式提供扩展功能。