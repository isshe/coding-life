
[TOC]

# Kqueue
* 通用和可扩展的事件通知工具（Ageneric and scalable event notification facility）。

## 0. 摘要
* 当一个套接字或描述符上发生某些活动时，需要通知在UNIX平台上运行的应用程序，传统上是使用`poll()`或`select()`系统调用来完成。然而，随着描述符数量的增加，这些系统调用的性能不能很好地拓展（并不是很好）。并且这些接口也有其他的限制，如不能处理应用程序可能感兴趣的一些其他可能有趣活动。这些活动包括：信号、文件系统更改、AIO完成。本文介绍了一种通用的事件传递机制，它允许应用程序从各种事件源中进行选择，并以可扩展和有效的方式通知这些源的活动。 该机制可以扩展以覆盖未来的事件源而不改变应用程序接口。

## 1. 介绍
* 应用程序通常是事件驱动的，因为它们响应应用程序外部的事件或活动而执行其工作，并且随后以某种方式传递。因此，应用程序的性能通常取决于它能够检测和响应这些事件的效率。
* FreeBSD提供了`poll`和`select`两个用于检测文件描述符活动的系统调用。 但是，由于事件监视的描述符数量变大，因此这些调用都不能很好地扩展。 打算处理数千个描述符的高容量服务器很快发现这些调用成为瓶颈，导致性能不佳。
* 应用程序可能感兴趣的事件集不限于打开文件描述符上的活动。应用程序可能还想知道异步I/O（aio）请求何时完成，何时将信号传递给应用程序，何时文件系统中的文件以某种方式更改，或者进程何时退出。 目前这些都没有得到有效处理; 信号传递是有限且昂贵的，并且列出的其他事件需要低效的轮询模型。 此外，poll和select都不能收集这些事件，导致由于使用多个通知接口而导致代码复杂性增加。
* 本文介绍了一种新机制，允许应用程序在特定事件中注册感兴趣的内容，然后在以后有效地收集事件通知。 这些机制所涵盖的事件集合不仅包括上述内容，还可以扩展到无法预见的事件源，而无需修改API。
* 本文的其余部分结构如下：第2节检查poll和select的主要瓶颈在哪里；第3节解释设计目标；第4节介绍新机制的API； 第5节详细介绍如何使用新API并提供了一些编程示例；第6节讨论内核实现；第7节是某些应用程序的性能测量；第8节讨论相关工作；第九节是总结。

## 2. 问题(select/poll的问题)
* poll和select接口的缺陷是：应用程序必须在每次调用中`传递`整个监视描述符列表。这直接导致系统在用户/内核空间存在两份内存副本，从而减少了可用于其他活动的内存带宽量。对于包含数千个描述符的大型列表，时间经验表明，通常只有几百个是活动的，因此95%的副本是不需要的。
* 在poll/selectf返回之后，应用程序必须遍历描述符列表才能找到内核标记为`活动`的描述符。由于内核知道哪些描述符是活动的，因此会导致重复的工作；应用程序必须重新计算系统以及知道的信息。让内核直接返回一个它已经知道的活动的列表似乎是更高效得做法。遍历列表复杂度是O(N), N越大拓展性越差。
* 在内核中，情况也不理想。必须找到空间来保存描述符列表；对于大型列表，可以通过调用malloc来完成，并且必须在返回之前释放该区域。执行复制后，内核必须检查每个条目以确定描述符上是否有未决的活动。如果内核在当前扫描中没有发现任何活动的描述符，则更新描述符的`selinfo`字段；这个信息是用来唤醒在等待描述符活动时调用tsleep的进程。唤醒进城后，它会再次扫描列表，查找当前处于活动状态的描述符。
* 这会导致3此描述符列表的传递。第一次遍历列表查找未处理事件和记录选择信息；第二次查找其活动导致唤醒描述符；第三次是用户空间，用户遍历列表查找内核标记为活动的描述符。
* 这些问题源于poll/select在设计上无状态的事实；也就是说，内核不会保留应用程序感兴趣的任何记录，而是每次都重新计算。该设计决定了不在内核中保持任何状态，导致当前实现中的低效率。如果内核能够准确跟踪应用程序感兴趣的描述符，并且返回那些活动的描述符，则可以消除大部分开销。

## 3. 设计目标
* 在设计替换设施时，主要目标是创建一个高效且可扩展到大量描述符的系统，大约数千个。 次要目标是使系统灵活。 基于UNIX的机器在传统上缺乏用于事件通知的强大工具。 poll和select接口仅限于套接字和管道描述符; 用户无法等待其他类型的事件，如文件创建或删除。 其他事件要求用户使用不同的接口; 尤其是siginfo和family必须用于获取信号事件的通知，并且需要调用aiowait来发现AIO调用是否已完成。
* 另一个目标是保持接口足够简单以便于理解，并且只需最小的更改就可以将基于poll()或select()的应用程序转换为新API。 人们认识到，如果新接口完全不同，那么它本质上是阻止了遗留应用程序利用新API进行修改。
* 将返回到应用程序的信息量拓展到不仅仅是发生事件也被认为是可取的。对于可读套接字，用户可能想知道套接字缓冲区中实际待读的字节数，以避免多次read调用。对于侦听套接字，应用程序可能会检查侦听backlog的大小，一遍适应提供的负载。在设计新的设施时，请牢记提供更多信息这个目标。
* 该机制也应该是可靠的，因此它永远不会无声地失败或向用户返回不一致的状态。 这个目标意味着不应该有任何固定大小的列表，因为它们可能会溢出，并且任何内存分配必须在系统调用时完成，而不是在活动发生时完成，以避免因内存不足而丢失事件。
* 例如，考虑几个网络数据包到达套接字的情况。 我们可以将每个传入的数据包视为离散事件，为每个数据包记录一个事件。 但是，传入数据包的数量基本上是无限制的，而系统中的存储量是有限的; 我们无法保证不会丢失任何事件。
* 上述场景的结果是多个数据包合并为单个事件。 传递给应用程序的事件可以对应于被监视的事件源上的多次活动。
* 另外，假设一个数据包到达时包含N个字节，并且应用程序在收到事件通知后，从套接字中读取R字节，其中R <N。下次调用事件API时，将不会通知 （N-R）字节仍然在套接字缓冲区中挂起，因为事件将根据到达的数据包来定义。 这会强制应用程序执行额外的簿记，以确保它不会错误地丢失数据。 对应用程序施加的额外负担与提供简单接口的目标冲突，因此导致以下设计决策。
* 事件通常被认为是“水平触发的”，而不是“边缘触发的”。 另一种说法是，只要指定条件成立，就会报告事件，而不是从事件源实际检测到活动时报告。 给定条件可以像“缓冲区中有未读数据”一样简单，也可以更复杂。 此方法处理上述场景，并允许应用程序对缓冲区执行部分读取，但在下次调用API时仍会收到事件通知。 这对应于poll()和select()提供的现有语义。
* 最终的设计标准是API应该是正确的，因为只有在适用时才应报告事件。 考虑数据包到达套接字的情况，进而生成事件。 但是，在通知应用程序此挂起事件之前，它会对套接字执行close()。 由于套接字已经关闭，因此不应再将事件传递给应用程序，因为它不再相关。 此外，如果事件恰好发生在某标识标识文件描述符，并且创建了另一个具有相同标识的描述符，则应该删除该事件，以排除对错误描述符的错误通知的可能性。
* 正确性要求还应扩展到预先存在的条件：在事件源在应用程序向API注册其兴趣事件之前生成事件。 这消除了在`应用程序在套接字中注册其兴趣事件`时`待读数据可能已经在套接字缓冲区`的竞争条件。 该机制应该认识到待处理数据满足“水平触发”要求并基于该信息创建事件。
* 最后，API的最后一个设计目标是，库应该可以使用该机制而不必担心与主程序冲突。 这允许使用API的第三方代码链接到应用程序而不会发生冲突。 虽然从表面上看这似乎是显而易见的，但仍存在一些反例。 在一个过程中，信号可能只有一个信号处理程序注册，因此库代码通常不能使用信号。 X-window应用程序仅允许单个事件循环。 现有的select()和poll()调用没有这个问题，因为它们是无状态的，但是我们的新API将一些状态移动到内核中，每个进程必须能够有多个事件通知通道。

### 3.1 目标总结
* 主要目标：创建一个搞笑且扩展性好的系统/机制。
* 次要目标：使系统灵活。
* 其他目标：
    * 保持接口足够简单，便于理解。
    * 新的机制应该是可靠地：永远不会无声地失败或想用户返回不一致的状态。
    * 事件是"水平触发"的。
    * API应该是正确的。（最终设计标准）
    * 库应该可以使用该机制而不必担心与主程序冲突。（多个地方使用，但不会冲突）

## 4. Kqueue API
* 引入了以下两个新系统调用。第一个创建了一个新的kqueue，它是一个通知通道或队列，应用程序在其中注册它感兴趣的事件，以及从内核检索事件的位置。 来自kqueue()的返回值被视为普通描述符，并且可以依次传递给poll/select，甚至可以在另一个kqueue中注册。
```c
// macOS 10.14.5 中还有其他几个接口
int kqueue(void);

int kevent(int kq, const struct kevent *changelist, int nchanges,
    struct kevent *eventlist, int nevents,
    const struct timespec *timeout);

struct kevent {
    uintptr_t       ident;          /* identifier for this event */
    int16_t         filter;         /* filter for event */
    uint16_t        flags;          /* general flags */
    uint32_t        fflags;         /* filter-specific flags */
    intptr_t        data;           /* filter-specific data */
    void            *udata;         /* opaque user data identifier */
};

EV_SET(&kev, ident, filter, flags, fflags, data, udata);
```
* 应用程序使用第二个调用来向kqueue注册新事件，并取回任何挂起事件。 通过组合注册和取回过程，减少了所需的系统调用次数。 应该应用于kqueue的更改在`changelist`中给出，并且任何返回的事件都放在事件列表中，直到达到`nevents`允许的最大大小。 实际放置在事件列表中的条目数由kevent()调用返回。 `timeout`参数的行为方式与poll()相同; 零值结构将在不休眠的情况下检查待处理事件，而NULL值将被阻塞直到被唤醒或事件准备就绪。 应用程序可以选择通过在适当的情况下为`nchanges`或`nevents`传递零值来分离注册和取回调用。
* 应用程序通过struct kevent向系统注册事件，并且通过<kq，ident，filter>元组在系统内唯一地标识事件。 实际上，这意味着给定的kqueue只能有一个<ident，filter>对。
* `filter`参数是一小段内核代码的标识符，当存在来自事件源的活动时执行该内核代码，并且负责确定是否应该将事件返回给应用程序。`ident`，`fflags`和`data`字段的解释取决于使用哪个过滤器来表示事件。 当前的过滤器列表及其参数显示在kqueue过滤器部分章节中。
* flags字段用于表示kevent在向系统注册时应采取的操作，并且还用于在返回时返回与过滤器无关的状态信息。 有效flags如如下：
    * 输入flags: 
        * EV_ADD: 添加事件到kqueue。
        * EV_ENABLE: 允许kevent()返回触发的事件。
        * EV_DISABLE: 禁用该事件，以便kevent()不会返回它。 过滤器本身未禁用。
        * EV_DELETE: 从kqueue删除事件；描述符关闭后，事件会自动删除。
        * EV_CLEAR: 在用户取回事件后，其状态将被重置。 这对于报告状态转换而不是当前状态的过滤器很有用。 请注意，某些过滤器可能会在内部自动设置此标志。
        * EV_ONESHOT: 事件发生时只触发一次，用户从kqueue中取回事件后，将删除该事件。
    * 输出flags:
        * EV_EOF: 过滤器可以设置此标志以指示特定于过滤器的EOF条件。
        * EV_ERROR: 错误发生，此标记被设置。
* `udata`字段不变地传入和传出内核，并且不以任何方式使用。 该字段的使用完全取决于应用程序，并且提供一个方式：有效实现函数调度例程，或以其他方式将应用程序标识符添加到kevent结构中。

### 4.1 Kqueue 过滤器
* kqueue系统的设计基于过滤器的概念，过滤器负责确定事件是否已经发生，并且还可以记录要传递回用户的额外信息。 kevent结构中某些字段的解释取决于使用哪个过滤器。 当前的实现带有一些通用事件过滤器，适用于大多数用途。这些过滤器包括：
    * EVFILT_READ
    * EVFILT_WRITE
    * EVFILT_AIO
    * EVFILT_VNODE
    * EVFILT_PROC
    * EVFILT_SIGNAL
* `EVFILT_READ`和`EVFILT_WRITE`过滤器可用于处理任何文件描述符，`ident`字段包含描述符编号。 这些过滤器密切反映了poll()或select()的行为，因为只要有数据准备好读取，或者应用程序可以不阻塞地写入，它们就会返回。 与过滤器对应的内核函数取决于描述符类型，因此实现是针对所使用的每种类型的描述符的要求而定制的。 通常，准备读取（或能够写入）的数据量将在kevent结构内的数据字段中返回，其中应用程序可以以任何方式自由地使用该信息。 如果底层描述符支持`EOF`的概念，则一旦检测到`EV_EOF`标志将在`flags`中设置，无论是否还有数据留给应用程序读取。
* 例如，只要套接字缓冲区中的数据大于SO_LOWAT标记，或者套接字已关闭(shutdown)且无法再接收任何数据，就会触发套接字描述符的`READ`过滤器。 过滤器将返回套接字缓冲区中待处理的字节数，并为shutdown案例设置EOF标志。 这为应用程序在处理事件时提供了更多可以使用的信息。 由于在套接字关闭时显式返回EOF，应用程序不再需要对read()进行额外调用以发现EOF条件。
* 一个非`kqueue-aware`应用程序使用异步I/O(aio)工具通过aio_read()或aio_write()来启动I/O请求，然后请求独立于应用程序进行，该应用程序必须重复调用ai_error()检查请求是否已完成，然后最终调用aio_return()来收集请求的完成状态。`EVFILT_AIO`过滤器通过允许用户在发出I/O请求时使用指定的kqueue注册aio请求来替换此轮询模型，并且当aio_error()成功返回时，在相同条件下返回事件。 这允许应用程序发出aio_read()调用，继续执行主事件循环，然后在从kqueue返回对应于aio的kevent时调用aio_return()，从而在进程中保存多个系统调用。
* `EVFILT_SIGNAL`滤波器旨在与正常的信号处理机器一起工作，提供另一种信号传输方法。 `ident`字段被解释为信号编号，并且在返回时，`data`字段包含信号发送到应用程序的频率计数。 该过滤器通过在应用程序收到事件通知后清除其状态（信号发生次数），在内部使用EV_CLEAR标志。
* `EVFILT_VNODE`过滤器旨在允许用户注册对文件系统中发生的兴趣的更改。 因此，`ident`字段应包含对应于打开文件或目录的描述符。 `fflags`字段用于指定应用程序在注册时感兴趣的描述符上的哪些操作，在返回时，已经发生了哪些操作。 这些操作可能是：
    * NOTE DELETE
    * NOTE WRITE
    * NOTE EXTEND
    * NOTE ATTRIB
    * NOTE LINK
    * NOTE RENAME
* 这些操作对应于文件系统对文件执行的操作，因此这里不再解释。 如果发生了多个动作，这些注释可以在返回的kevent中一起进行`OR-d`【？？？】。 例如：编写了一个文件，然后重命名。
* `EVFILT_PROC`过滤器，用于检测过程变化。 对于此过滤器，`ident`字段被解释为进程标识符。 此过滤器可以监视多种类型的事件，控制此过滤器的`fflag`如下所示：
    * 输入/输出标记：
        * NOTE_EXIT: 进程退出；
        * NOTE_FORK: 进程调用fork();
        * NOTE_EXEC: 进程执行的新的程序。（execve()或其他类似的函数）
        * NOTE_TRACK: 遵循fork()调用的过程。 父进程将返回并在`flags`字段中设置`NOTE_TRACK`，而子进程将返回，其中`NOTE_CHILD`设置为`fflags`，父PID在`data`字段。
    * 输出标记：
        * NOTE_CHILD: 这是一个调用fork()的`TRACKed`进程的子进程。(见前一项)
        * NOTE_TRACKERR: 如果系统无法将事件附加(attach)到子进程，则会返回此标志，这通常是由于资源限制。

## 5. 使用和示例
* Kqueue旨在通过有效地通知用户需要注意的事件来减少poll()和select()所产生的开销，同时还尽可能多的提供关于该事件的信息。 然而，kqueue并不是为了取代poll而设计的; 为了从系统中获得最大的好处，需要利用kqueue提供的独特接口重写现有的应用程序。
* 围绕poll构建的传统应用程序会具有包含所有活动描述符的单个结构，每次应用程序进行事件循环时都会将其传递给内核。 使用了kqueue的应用程序只需要通知内核对活动描述符列表的任何更改，而不是传递整个列表。 这可以通过为活动描述符列表的每次更新调用kevent()，或者通过构建描述符更改列表，然后在下次调用事件循环时将此列表传递给内核来完成。 后一种方法提供了更好的性能，因为它减少了系统调用的数量。
* 虽然先前用于kqueue的API部分最初可能看起来很复杂，但大部分复杂性源于存在多个事件源和多个过滤器的事实。 只想要READ/WRITE事件的程序实际上非常简单。 以下页面中的示例说明了如何使用poll()的程序可以轻松转换为使用kqueue()，并且还提供了说明其他过滤器使用方法的几个代码片段。
* [1_1_ex](./Examples/1_1_ex_original_poll_code.c)中的代码说明了poll()系统调用的典型用法，而[1_2_ex](./Examples/1_2_ex_kevent_code.c)中的代码是使用kqueue的相同代码的`linebyline`转换。 虽然这是一个简化的例子，但两个调用之间的映射相当简单。 转换的主要障碍可能是缺少与更新fd等效的函数，这会更改包含pollfd或kevent结构的数组。
* 如果在注册新kevent之前将`udata`字段初始化为正确的函数，则可以进一步简化调度循环，如[1_3_ex](./Examples/1_3_ex_kqueue_udata.c)所示。
* [1_4_ex](./Examples/1_4_ex_kqueue_signal_delivery.c)包含一段代码，说明如何将信号事件传递给应用程序。 注意对signal()的调用，它建立了一个NULL信号处理程序。 在此调用之前，信号的默认操作是终止进程。 忽略信号只是意味着在信号传递到进程后不会调用信号处理程序。
* [1_5_ex](./Examples/1_5_ex_kevent_watch_file_changes.c)显示了监听与ufs文件系统上的文件相对应的描述符以进行指定更改的代码。 注意使用`EV_CLEAR`，它会在返回后重置事件; 如果没有此标志，将重复返回该事件。
* 使用以下示例可以最好地说明`PROC过滤器`的行为。 PROC过滤器可以附加到应用程序可以看到的系统中的任何进程，它不仅限于其后代。 过滤器可以附加到特权进程; 没有安全隐患，因为所有信息都可以通过'ps'获得。 术语“see”特定于FreeBSD的jail代码，它将某些进程组彼此隔离开来。
* 如果在进程过滤器中设置了`FORK`标志，则每个fork()都有单个通知。 如果设置了`TRACK`标志，则过滤器实际上创建并注册一个新的`knote`，该knote又附加到新进程。 这个新的knote会立即激活，并设置`CHILD`标志。
* 添加了fork功能以跟踪进程的执行。 例如，假设为进程A注册了带有标志（FORK，TRACK，EXEC，EXIT）的`EVFILT_PROC`过滤器，进程A然后分离两个子进程，进程B和C.进程C然后立即分叉另一个进程D， 调用exec()来运行另一个程序，然后退出。 如果应用程序此时调用kevent()，则会发现4个kevents正在等待：(进程结束了，相关事件还存在？)
    * ident: A, fflags: FORK
    * ident: B, fflags: CHILD data: A
    * ident: C, fflags: CHILD, FORK data: A
    * ident: D, fflags: CHILD, EXEC, EXIT data: C
* 附加(attach)到子进程的`knote`负责返回父和子进程ID之间的映射。

## 6. 实现

### 6.1 注册

### 6.2 过滤

### 6.3 事件源的活动

### 6.4 传递

### 6.5 杂项说明

## 7. 性能

## 8.相关工作

## 9.结论

## 10.引用
