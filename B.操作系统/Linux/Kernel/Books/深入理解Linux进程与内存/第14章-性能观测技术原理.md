# 第十四章 性能观测技术原理

## 问题

- 事件类型
- 静态追踪开启/关闭
- 静态追踪的原理
- 动态追踪开启方式
- 动态追踪的原理
- INT3 是什么？
- 替换以后，如果处理逻辑出错了，地址被修改了，怎么保证系统继续正常运行的呢？
- kprobe 都需要编译成 ko？
- 有宕机风险吗？
- perf 命令使用

## 解答

### 事件类型

- 硬件事件：Hardware Event，查看事件列表的命令：`perf list hw cache`。事件示例：CPU 执行指令数、时钟周期数、L1/TLB 缓存相关事件等。
- 软件事件：Software Event，查看事件列表的命令：`perf list sw`。事件示例：进程上下文切换、缺页中断等
- 静态追踪点事件：Tracepoint Event，查看事件列表的命令：`perf list tracepoint` 或 `ls /sys/kernel/debug/tracing/events/`。

### 静态追踪开启/关闭

示例：

```bash
# 开启
echo 1 > /sys/kernel/debug/tracing/events/syscalls/sys_enter_open/enable
perf trace -e syscalls:sys_enter_open
perf record -e sched:sched_switch -a
bpftrace -e 'tracepoint:syscalls:sys_enter_open { printf("%s\n", comm); }'
trace-bpfcc 't:syscalls:sys_enter_open'
stap -e 'probe kernel.trace("sys_enter") { println(execname()) }'

# 关闭
echo 0 > /sys/kernel/debug/tracing/events/syscalls/sys_enter_open/enable

# 查看追踪结果
cat /sys/kernel/debug/tracing/trace
```

### 静态追踪的原理

核心思想：在代码中预先埋入追踪点（hook），运行时可动态开启/关闭。

主要用于定义追踪点的宏：

- DECLARE_TRACE：声明追踪点，在**头文件（.h）**中声明一个追踪点接口
- DEFINE_TRACE：定义追踪点，在**源文件（.c）**中定义追踪点的实现
- TRACE_EVENT：定义完整的追踪事件，一次性定义完整的追踪事件，包括数据格式、输出格式等，在 trace/events/ 目录下的头文件中。
- DO_TRACE：执行追踪逻辑，实际执行追踪点的底层实现（内部宏，通常不直接使用）。调用链：`trace_xxx() → __DO_TRACE() → 遍历回调函数链 → 写入 ring buffer`

TRACE_EVENT 是 DECLARE_TRACE 和 DEFINE_TRACE 的高级封装，是内核主流方式，推荐使用。

实现机制：

1. 编译时插桩

```c
// 内核代码中的追踪点定义
TRACE_EVENT(sched_switch,
    TP_PROTO(struct task_struct *prev, struct task_struct *next),
    TP_ARGS(prev, next),
    ...
);

// 在关键位置调用
trace_sched_switch(prev, next);
```

2. 运行时开销控制

- 未开启时：追踪点是 NOP 指令（空操作），几乎零开销
- 开启后：NOP 被替换为 跳转指令，执行追踪逻辑
- 使用 jump label 技术实现动态切换

3. 数据流转

代码执行 → 触发追踪点 → 写入 ring buffer → 用户态读取

### 动态追踪开启方式

```bash
cd /sys/kernel/debug/tracing

# 创建跟踪点
echo 'p:test schedule' >> kprobe_events

# 开启
echo '1' > events/kprobes/test/enable

# 查看跟踪输出
cat /sys/kernel/debug/tracing/trace_pipe

# 关闭
echo '0' > events/kprobes/test/enable
```

创建名为 test 的跟踪点，同时会生成对应的目录，位于 `/sys/kernel/debug/tracing/events/kprobes/test`。
还可以通过 perf 进行使用：

```bash
$ perf probe --list | grep test
  kprobes:test         (on schedule@kernel/sched/core.c)

# 录制
perf record -e kprobes:test -a -g sleep 1

# 分析录制内容
perf script
```

### 动态追踪的原理

1. 插入断点：用 INT3 指令（0xCC，单字节）替换目标函数的第一条指令
2. 触发中断：执行到 INT3 时触发断点异常，进入内核异常处理
3. 执行探针：调用注册的 pre_handler（前置处理函数）
4. 单步执行：设置单步标志，执行原始指令
5. 恢复执行：调用 post_handler（后置处理函数），继续正常流程

### INT3 是什么？

- x86 断点指令，单字节（0xCC）
- 触发 CPU 异常，让内核接管控制
- Linux 5.5 前叫 BREAKPOINT_INSTRUCTION，后改名 INT3_INSN_OPCODE

INT3：INT3_INSN_OPCODE，在 Linux 5.5 版本之前，是 BREAKPOINT_INSTRUCTION 指令。

### 替换以后，如果处理逻辑出错了，地址被修改了，怎么保证系统继续正常运行的呢？

- 原子操作：使用 text_poke() 原子修改代码段，保证多核一致性
- 备份原指令：kprobe 保存被替换的原始指令，用于恢复和单步执行
- 异常处理：如果探针函数崩溃，内核异常处理会捕获并隔离
- 自动清理：探针注册失败或异常时，自动恢复原始指令
- 只读保护：临时解除代码段写保护，修改后立即恢复

### kprobe 都需要编译成 ko？

不一定，有多种方式：

```bash
# 1. eBPF（推荐，无需 ko）
bpftrace -e 'kprobe:do_sys_open { printf("%s\n", comm); }'

# 2. perf（无需 ko）
perf probe --add do_sys_open

# 3. ftrace（无需 ko）
echo 'p:myprobe do_sys_open' > /sys/kernel/debug/tracing/kprobe_events

# 4. 内核模块（需要 ko）
insmod my_kprobe.ko
```

### 有宕机风险吗？

有，但可控：

风险：探针函数崩溃、死锁、性能下降

防护：

- eBPF 有验证器，保证安全
- 关键函数有黑名单，禁止探测
- 避免探测高频函数（如 schedule）

推荐：生产环境用 eBPF，最安全

### perf 命令的使用方法

详见：[perf 命令](../../../../Linux/Commands/perf.md)。
