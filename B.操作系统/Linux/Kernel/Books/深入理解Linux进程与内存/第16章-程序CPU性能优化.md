# 第十六章 程序 CPU 性能优化

## 问题

- 栈访问有时候比堆快几倍或十几倍，是为什么？
- 微服务的局限性？
- 性能优化的方式有哪些？
- 优化案例。

## 解答

### 栈访问有时候比堆快几倍或十几倍，是为什么？

通常是因为局部性原理。栈的访问较为相近（先进后出），更符合局部性原理，缓存命中率更高。

### 微服务的局限性？

- 调用从微秒级变成了毫秒级（RPC、远程过程调用）。
- 大量 CPU 资源开销：编解码、内核协议栈处理、内核进程调度等。

因此，不应该过度微服务化，需要合理设计。

### 性能优化的方式有哪些？

- 应用层优化：
  - 优化热点函数：通过火焰图等识别出开销大的函数调用，进行优化
  - 较少不必要的业务逻辑处理：对业务进行瘦身，但是会带来兼容性风险 —— 通常只增不减是稳妥的方式。
  - 算法/数据结构优化：使用合理的数据结构数组、链表、栈、队列、树、哈希表、bitmap、布隆过滤器等。
  - 合理地微服务：避免过度微服务
  - 内存对齐：CPU 硬件取内存数据是以 64 bits（8 bytes）为单位的。内存对齐以较少内存的方法。例如将 2 次访问优化成 1 次。同样 L1/2/3 等缓存是以 Cacheline 为单位的，通常是 512 bits（64 bytes）。因此，程序变量大小最好控制在 8 bytes 或 64 bytes 以内并对齐。
  - 编写缓存友好的代码：让程序持续运行需要读取的数据尽量挨在一起。例如对于 a[m][n] 数组，将各行都放到一起，紧挨着。第一行后面就是第二行；第二行后面就是第三行。
- 编程语言及框架优化：
  - 选择合适的编程语言：性能要求高 C、Rust；开发及性能均衡 Golang、Java；不追求性能 Python 脚本语言等。
  - 选择合适的网络 IO 编程模型：同步阻塞、多路复用。
  - 选择合适的内存分配方案：glibc、tcmalloc、jemalloc 等
- 内核调优：
  - 减少系统调用：用户态函数调用纳秒级，系统调用则是微秒级甚至毫秒级。
  - 虚拟内存优化：
    - 禁止交换：禁止将内存数据交换到硬盘中。
    - 使用大页：默认通常是 4 KB。改成大页例如 2 MB，可以减少缺页中断，提升 TLB 缓存命中率。查看命中率等情况：`perf stat -e dTLB-load-misses,iTLB-load-misses,page-faults`
  - 调度器优化：
    - 使用实时进程：查看并调整进程的调度策略。可以通过 chrt（Change real-time）命令来调整。详见[chrt 命令](../../../Commands/chrt.md)
    - 调整普通进程的 nice 值，让指定进程能获取到更多 CPU 资源。
    - 调整 CPU 亲和性（绑核）：进程调度通常已经有软亲和（内核偏向于不将进程调度到其他核心），但是不是强制的。可以使用 taskset 命令进行绑定。场景：有些服务消耗大但是非核心，那么限制它只能运行在指定核心上，避免影响整体服务。
    - 调整 throttle 情况：如果关注的进程对 CPU 的消耗大于预期设置的限制，则可能频繁 throttle，导致服务延迟、不稳定。
      - 可以重新考虑调大限制：同时调大 cpu.cfs_period_us 和 cpu.cfs_quota_us，减少短时间内额度被用完的情况，减少 throttle。
      - 也可以考虑允许 Burst。
  - 避免过小的容器实例，避免频繁的进程调度、核间迁移。综合考虑，100 核的设备，容器单实例核心数量至少应保持 8 核以上，不建议**大量**使用 1 或 2 核的小实例来提供服务。
  - 离线调度器：修改调度器，区分在线和离线任务。离线任务通常需要占用大量 CPU 资源。
    - 腾讯的 Tencent-OS 就实现了这样的调度算法 BT。
- 网络协议栈优化：
  - 减少不必要的网络请求：网络请求的处理链路很长，开销很大。
  - 减少网络传输距离：缩短客户端与服务器的距离，部署得近一些。
  - 优先使用内部网络
  - 多队列网卡 RSS（Receive Side Scaling）调优：修改队列数量、使用 irqbalance 指定选择绑定核心
    - `ethtool -L eth0 combined 32`
    - irqbalance 通常是开启的。需要自行绑定时，可以再关闭并通过 smp_affinity 调整。
  - 使用零拷贝技术：通过 sendfile 系统调用实现。
  - Kernel-Bypass：绕开内核，例如 DPDK、QAT（？）。
- 基础设施优化：
  - 提升 CPU 硬件：使用缓存更大、频率更高的 CPU。
  - 开启睿频
  - 关闭超线程：在想要单核性能更强的情况下，可以考虑关闭超线程。
  - 硬件卸载：将特定的计算任务从软件层移到硬件层，利用专用的硬件来完成特定的计算任务，减轻 CPU 的压力。例如智能网卡，能实现 TCP 包的校验、流量控制、DDoS 检测和防御。除了网络，存储、加密等场景都有一些专用的硬件。
  - 容器云部署：将服务迁移到容器云上，实现对 CPU、内存等宝贵资源的充分利用。

### 优化案例

TODO P525 unlike/like：涉及缓存局部性原理以及 CPU 指令流水线技术，帮助 CPU 提高流水线效率。
分支预测正确率变高后：
- 缓存命中率提高
- CPU 流水线效率更高
