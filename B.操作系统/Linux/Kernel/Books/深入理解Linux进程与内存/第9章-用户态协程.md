# 第九章 用户态协程

## 问题

- GO 协程（GMP）的原理？GMP 分别代表什么？
- GO 程序的启动过程？
- GOMAXPROCS 是什么？
- Go 内部常用的 systemstack 是什么？
- Go 内部是如何唤醒线程去执行协程的呢？怎么控制的？这个不是应该是操作系统控制的吗？
- Go 实现中似乎能从汇编直接调用到 Go 代码（例如 newproc 之类的函数），怎么做到的？
- Go 中栈溢出是怎么判断的？和操作系统的判断方式一样吗？
- 将 stackguard0 设置为 stack.lo + _StackGuard 为何能用于判断是否需要扩容？
- 调度的时候，如果获取不到空闲的 M（线程）就创建，不会越来越多吗？M 和 P 不是一一对应的关系么？为什么？
- Go 支持多进程吗？多进程的时候，是怎么调度的呢？

## 总结

### GO 协程（GMP）的原理？GMP 分别代表什么？

TODO

创建线程，将协程绑定到线程上，让操作系统调度线程，从而再由 GO 调度协程。

### GO 程序的启动过程？

`_rt0_amd64_linux` 入口源码：https://github.com/golang/go/blob/master/src/runtime/asm_amd64.s


### GOMAXPROCS 是什么？


### Go 内部常用的 systemstack 是什么？

### Go 内部是如何唤醒线程去执行协程的呢？怎么控制的？这个不是应该是操作系统控制的吗？

> 对应书中 p284 倒数第三行。

### Go 实现中似乎能从汇编直接调用到 Go 代码（例如 newproc 之类的函数），怎么做到的？

### Go 中栈溢出是怎么判断的？和操作系统的判断方式一样吗？

### 将 stackguard0 设置为 stack.lo + _StackGuard 为何能用于判断是否需要扩容？

### 调度的时候，如果获取不到空闲的 M（线程）就创建，不会越来越多吗？M 和 P 不是一一对应的关系么？为什么？

## 参考

- golang 源码：https://github.com/golang/go
