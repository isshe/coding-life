# 第九章 用户态协程

## 问题

- GO 协程（GMP）的原理？GMP 分别代表什么？
- 为何要定义出 GMP 这样的概念？
- GO 程序的启动过程？Go 程序启动时是如何创建 G、M、P，并切懂协程调度系统运行，最后进入 main 函数的？
- GOMAXPROCS 是什么？
- Go 内部常用的 systemstack 是什么？
- 为什么需要 systemstack？
- Go runtime 如何让操作系统唤醒线程来执行 goroutine？线程的调度不是由操作系统控制的吗？
- Go 实现中似乎能从汇编直接调用到 Go 代码（例如 newproc 之类的函数），怎么做到的？
- 协程栈内存是如何实现的？
- Go 中栈溢出是怎么判断的？和操作系统的判断方式一样吗？
- 将 stackguard0 设置为 stack.lo + _StackGuard 为何能用于判断是否需要扩容？
- 调度的时候，如果获取不到空闲的 M（线程）就创建，不会越来越多吗？M 和 P 不是一一对应的关系么？为什么？
- Go 支持多进程吗？多进程的时候，是怎么调度的呢？
- Go 的原生 net 包是如何通过协程和 epoll 机制给用户封装出同步编程方式的？

## 总结

### GO 协程（GMP）的原理？GMP 分别代表什么？

G：Goroutine。Go 协程，是 Go 语言中的轻量级线程，包含了协程的执行栈、程序计数器、状态信息等，每个 G 代表一个待执行或正在执行的任务，初始栈大小仅 2KB，可动态增长。
M：Machine。代表操作系统线程（OS Thread），是真正执行计算的资源，由操作系统管理和调度，M 必须绑定 P 才能执行 G，数量可以动态增长，但有上限（默认 10000）
P：Processor。逻辑处理器，启动时创建，代表执行 Go 代码所需的资源和上下文，持有 G 的本地运行队列（Local Run Queue），数量默认等于 CPU 核心数（可通过 GOMAXPROCS 设置）。

G、M、P 的定义再 src/runtime/runtime2.go 中。分别为：

- type g struct
- type m struct
- type p struct

调度链路：

- 操作系统层面：OS Scheduler → 调度 M (OS Thread) → M 获得 CPU 时间片
- Go Runtime 层面：M 获得 CPU → 检查是否绑定 P → 从 P 的本地队列获取 G → 执行 G

关键要点：

- 操作系统调度的是 M (线程)，不知道 P 和 G 的存在
- P 持有 G 的本地队列，不是 M
- M 必须绑定 P 才能执行 G
- P 的数量固定（等于 GOMAXPROCS），在程序启动时初始化
- M 的数量动态变化，按需创建
- G 的数量由用户代码决定，可以有成千上万个

### 为何要定义出 GMP 这样的概念？

最初 Go（1.0 时代，2012 年之前）确实只有 G 和 M，没有 P，所有 M 共用一个全局的 G 队列。有以下问题：

- 全局锁竞争严重
- M 频繁切换导致缓存失效。例如：G1 在 M1 上执行一半，被放回队列，后续被调度到 M2 上执行，缓存失效。
- M 阻塞时无法复用资源。资源（mcache、defer 池等）是绑定在 M 上的，当 M 被阻塞时，其他 M 无法使用这些资源。GPM 模型中，则将资源绑定到了 P 上。
- 无法实现 Work Stealing，无法实现高效的负载均衡：从 M 每次从全局队列取一个 G，变成从某个 P 队列中取一半 G。提高负载均衡效率。

在 Go 1.1 时，引入了 P 来解决上面的问题。

### GO 程序的启动过程？Go 程序启动时是如何创建 G、M、P，并切懂协程调度系统运行，最后进入 main 函数的？

```
1. _rt0_amd64_linux (汇编入口)
   ↓
2. runtime·rt0_go (汇编，设置栈、TLS，初始化 m0 和 g0)  // src/runtime/asm_amd64.s, m0 和 g0 在 src/runtime/proc.go 中定义为全局变量
   ↓
3. runtime·args (处理命令行参数)
   ↓
4. runtime·osinit (初始化 CPU 核心数)
   ↓
5. runtime·schedinit (调度器初始化，创建 P)
   ↓
6. runtime·newproc (创建 main goroutine - G)
   ↓
7. runtime·mstart (启动调度循环)    // src/runtime/proc.go: mstart -> mstart0 -> mstart1
   ↓
8. runtime·schedule (调度循环)      // src/runtime/proc.go: schedule
   ↓
9. runtime·execute (执行 main goroutine)    // src/runtime/proc.go: execute
   ↓
10. runtime·gogo (汇编实现，切换栈和 PC)    // src/runtime/asm_amd64.s, 通过汇编 `JMP BX` 跳转到 runtime·main
   ↓
11. runtime·main (runtime 的 main 函数)     // src/runtime/proc.go: main
    ↓
12. main·main (用户的 main 函数)            // src/runtime/proc.go: main_main，将 main_main 链接到 main·main
```

`_rt0_amd64_linux` 入口源码：https://github.com/golang/go/blob/master/src/runtime/asm_amd64.s

### GOMAXPROCS 是什么？

GOMAXPROCS 是 Go 语言中用来控制同时执行用户代码的操作系统线程数量上限的参数。

### Go 内部常用的 systemstack 是什么？

systemstack 是一个特殊的函数，它的作用是：在系统栈（g0 栈）上执行指定的函数，而不是在当前 goroutine 的栈上执行。

Go 中每个 M（线程）实际上有两个栈：

- g0 栈（系统栈/调度栈）
    - 固定大小（通常 8KB）
    - 用于执行 runtime 代码
    - 用于调度、GC 等系统操作

- 用户 goroutine 栈（g 栈）
    - 动态大小（初始 2KB）
    - 用于执行用户代码
    - 可以自动扩张/收缩

### 为什么需要 systemstack？

- 避免栈分裂（Stack Split）：栈扩张的时候，又触发栈扩张导致死循环或奔溃，因此栈扩张使用系统栈进行。
- 某些操作必须在系统栈上执行
  - 调度器操作
  - GC 操作
  - 内存分配器的某些操作：分配大对象、需要访问全局状态
  - 信号处理
- 性能考虑：某些频繁调用的 runtime 函数，在固定大小的 g0 栈上执行更快

### Go runtime 如何让操作系统唤醒线程来执行 goroutine？线程的调度不是由操作系统控制的吗？

> 对应书中 p284 倒数第三行。

是的。线程调度是由操作系统控制的。

Go runtime 不能直接控制线程调度，但可以通过系统调用"请求"操作系统唤醒线程：

1. Go 创建新 goroutine 时，检查是否需要更多线程
2. 如果需要，调用 wakep() → startm()
3. startm() 通过 futex 系统调用唤醒睡眠的线程
4. 操作系统收到请求，将线程标记为可运行
5. 操作系统在合适的时候调度线程到 CPU
6. 线程被调度后，执行 Go 调度器代码，获取 goroutine 执行

注意：调度器不是一个独立运行的实体，而是一组全局函数（如 schedule、findrunnable、execute），这些函数在“M 被唤醒时”、“G 执行完毕时”等多种情况下都会被执行。

### Go 实现中似乎能从汇编直接调用到 Go 代码（例如 newproc 之类的函数），怎么做到的？

Go 编译器编译时，会为每个 Go 函数生成符号（symbol），汇编代码可以直接引用这些符号；
链接的时候，将这些符号转换成对应的地址；
调用时，使用相同的参数传递方式、相同的栈布局，可以互相调用。

和 C 语言中汇编调用 C 函数一样，通过符号和链接器实现。

### 协程栈内存是如何实现的？

在创建协程时，通过 mmap 来为协程分配栈内存。

- 初始大小：2KB
- 最大大小：1GB (64 位) / 250MB (32 位)
- 按需增长：不够时自动扩张
- 自动收缩：空闲时自动缩小

### Go 中栈溢出是怎么判断的？和操作系统的判断方式一样吗？

Go 通过编译器在每个函数入口插入检查代码（比较 SP 和 stackguard0），主动检测栈溢出并自动扩张栈；而操作系统使用内存保护页（guard page）被动检测，访问时触发 SIGSEGV 导致进程崩溃。

详细对比：

操作系统（如 Linux）：
- 栈大小固定（如 8MB）
- 通过内存保护页（guard page）检测
- 访问保护页触发 SIGSEGV 信号
- 进程崩溃

Go Runtime：
- 栈大小动态（2KB 起）
- 编译器插入检查代码
- 主动检测，触发栈扩张
- 不会崩溃（除非超过最大值）

### 将 stackguard0 设置为 stack.lo + _StackGuard 为何能用于判断是否需要扩容？

stackguard0 = stack.lo + _StackGuard 在栈底上方留出保护区（928 字节），函数入口检查 `SP - framesize < stackguard0` 来判断是否有足够空间分配栈帧，如果小于则触发扩容。

### 是否有可能超过保护区？直接导致栈溢出检测不出来？

有可能，但 Go 通过多种机制防止：

1. 编译器限制：单个栈帧过大（> 保护区）的函数会被标记，运行时特殊处理
2. NOSPLIT 检查：编译时检查 NOSPLIT 函数链的总栈使用，超过限制则编译失败
3. 运行时检查：大栈帧函数会在入口做更严格的检查

### 调度的时候，如果获取不到空闲的 M（线程）就创建，不会越来越多吗？M 和 P 不是一一对应的关系么？为什么？

会增长，但有限制和回收机制。
不是一一对应的，会在需要的时候进行创建：

- 程序启动（M0）
- 需要执行 G，但没有空闲 M
- M 阻塞在系统调用，P 需要新的 M
- sysmon 检测到长时间系统调用，handoff P

### Go 的原生 net 包是如何通过协程和 epoll 机制给用户封装出同步编程方式的？

核心思想：将异步的 epoll 事件通知转换为同步的阻塞调用，通过 goroutine 调度实现。

用户视角（同步）：

```
conn.Read(buf)  // 阻塞等待数据
```

实际实现（异步）：

1. 发起非阻塞 read 系统调用
2. 返回 EAGAIN（数据未就绪）
3. 将 fd 加入 epoll 监听
4. gopark() 挂起当前 goroutine，让出 CPU
5. 调度器通过 netpoll 调用 epoll_wait 检测事件
6. epoll 通知数据就绪
7. goready() 唤醒 goroutine
8. 重新执行 read，读取数据

## 参考

- golang 源码：https://github.com/golang/go
