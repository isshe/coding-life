# 系统物理内存初始化

## 问题

- 申请内存得到的真的是物理内存吗？
- 对虚拟内存的申请如何转化为对物理内存的访问？
- top 命令输出进程的内存指标中 VIRT 和 RES 分别是什么含义？
- 栈的大小限制是多少？这个限制可以调整吗？默认的栈大小是多少？
- 当发生溢出后应用程序会发生什么？
- 进程栈和线程栈是相同的东西吗？
- 你知道 malloc 大致是如何工作的吗？
- 缺页中断会调用用户空间的函数（do_user_addr_fault）？
- maple tree 是什么？相比红黑树 + 双向链表有什么优势劣势？
- 虚拟内存地址空间的起始、结束地址是什么？是连贯的吗？
- 进程占用的物理内存都是不连续的，一块一块的吗？
- 内核将 SO、可执行文件加载到内存中的流程。
  - execve -> do_execve_common -> search_binary_handler -> load_elf_binary -> elf_map -> mmap_region
- 不同的 so，在不同的进程中，地址可能会是一样的吗？相同的 so 在不同的进程中呢？
- 线程栈可以动态拓展吗？为什么？
- 线程为何要在用户空间申请栈内存？
- 默认的线程栈空间是多大？如果设置了 rlimit 但是超过 32MB，那么会是多少？
- 进程栈和线程栈有哪些主要区别？有哪些相同点？
- 线程栈中都存储了哪些内容？

## TODO

运行书本中的示例并查看原代码了解原理：P165、P167、P170


## 总结

### 进程栈和线程栈有哪些主要区别？有哪些相同点？

区别：

- 进程栈是内核创建进程时申请的，线程栈是 glibc 申请的，内核不管
- 进程栈创建时只有 4KB，可以伸缩（动态拓展）；线程栈一次性申请指定大小的空间，没有伸缩功能
- 进程栈可以伸缩、线程栈不可以伸缩
  - golang 中是可以伸缩的，golang 运行时先分配小内存，不够用后，申请大内存，并复制数据过去。

相同：

- 进程栈和线程栈都受 ulimit 中 stack size 大小的限制。

### 线程栈中都存储了哪些内容？

- struct pthread 结构体
- 运行栈


### 程序申请内存后使用内存和内核从硬盘加载 elf 文件的内容到内存，都是通过缺页中断来处理的吗？

是的。缺页中断有不同的类型。

**1. Minor Page Fault（次缺页中断）**

- 场景：页面在内存中，但页表项未建立
- 处理：只需更新页表，不需要磁盘 I/O
- 例子：malloc 后首次访问

**2. Major Page Fault（主缺页中断）**

- 场景：页面不在内存中，需要从磁盘读取
- 处理：需要磁盘 I/O 操作
- 例子：访问被换出的页面，或首次访问文件映射的页面

场景汇总：

| 场景 | 是否使用缺页中断 | 时机 | 类型 |
|------|------------------|------|------|
| malloc/new 申请内存 | **是** | 首次访问时 | Minor Fault |
| ELF 文件加载 | **部分是** | 取决于访问模式 | Minor/Major Fault |
| 文件 mmap | **是** | 首次访问时 | Major Fault |
| 匿名 mmap | **是** | 首次访问时 | Minor Fault |
| 静态变量 | **可能** | 程序启动时可能预加载 | Minor Fault |
