# 系统物理内存初始化

## 问题

- 程序申请内存得到的真的是物理内存吗？
- 对虚拟内存的申请如何转化为对物理内存的访问？
- top 命令输出进程的内存指标中 VIRT 和 RES 分别是什么含义？
- 进程栈和线程栈是什么？是相同的东西吗？
- 进程栈和线程栈有哪些主要区别？有哪些相同点？
- 进程栈的大小限制是多少？这个限制可以调整吗？默认的栈大小是多少？Linux 内核源码中哪个宏或参数控制默认大小？
- 当发生栈溢出后应用程序会发生什么？
- 进程栈和线程栈是相同的东西吗？
- 线程栈可以动态拓展吗？为什么？
- 线程为何要在用户空间申请栈内存？
- 默认的线程栈空间是多大？如果设置了 rlimit 但是超过 32MB，那么会是多少？
- 线程栈中都存储了哪些内容？不同的分配器对于线程栈存储的内容都是一样的吗？使用方式都一样吗？
- 你知道 malloc 大致是如何工作的吗？
- 缺页中断会调用用户空间的函数（do_user_addr_fault）？
- maple tree 是什么？相比红黑树 + 双向链表有什么优势劣势？
- 虚拟内存地址空间的起始、结束地址是什么？是连贯的吗？
- 进程占用的物理内存都是不连续的，一块一块的吗？
- 内核将 SO、可执行文件加载到内存中的流程。
  - execve -> do_execve_common -> search_binary_handler -> load_elf_binary -> elf_map -> mmap_region
- 不同的 so，在不同的进程中，地址可能会是一样的吗？相同的 so 在不同的进程中呢？
- 程序申请内存后使用内存和内核从硬盘加载 elf 文件的内容到内存，都是通过缺页中断来处理的吗？

## TODO

运行书本中的示例并查看原代码了解原理：P165、P167、P170


## 总结

### 程序申请内存得到的真的是物理内存吗？

不是直接得到物理内存。
当程序中使用 `malloc` 或其他内存分配函数分配内存时，得到的是虚拟内存地址，而不是物理内存地址，最终是通过缺页中断来分配到物理内存。
物理内存分配流程：

```
用户程序 malloc()
    ↓
glibc 内存管理器
    ↓
系统调用 (mmap/brk)
    ↓
内核虚拟内存管理 (VMA)
    ↓
缺页异常处理
    ↓
物理内存分配 (伙伴系统)
    ↓
页表映射建立
    ↓
实际物理内存
```

### 对虚拟内存的申请如何转化为对物理内存的访问？

当访问时发现虚拟内存对应的物理内存页没有分配时，会触发缺页中断，在中断中调用伙伴系统的 alloc_page 进行分配。以**页**为单位。

可参考上一个问题答案中的“物理内存分配流程”。

### top 命令输出进程的内存指标中 VIRT 和 RES 分别是什么含义？

VIRT(Virtual Memory Size)：进程使用的**虚拟**内存总量，VIRT 包括：程序代码段 (text)、数据段 (data)、堆内存 (heap)、栈内存 (stack)、共享库映射、内存映射文件、其他虚拟内存区域。
RES(Resident Set Size)：进程使用的**物理**内存总量，RES 包括：已分配的物理页面、正在使用的内存、不包括被交换到磁盘的部分。

对比：

| 指标 | VIRT | RES |
|------|------|-----|
| **含义** | 虚拟内存总量 | 物理内存使用量 |
| **类型** | Virtual Memory | Physical Memory |
| **大小** | 通常较大 | 通常较小 |
| **变化** | 申请内存时增加 | 实际访问时增加 |
| **共享库** | 每个进程都计算 | 按实际占用计算 |
| **交换内存** | 包含 | 不包含 |


### 进程栈和线程栈是什么？是相同的东西吗？

**进程栈**（也称为**主线程栈**）是进程主线程使用的栈空间，**位于进程虚拟地址空间的栈段，通常在高地址处向下增长**。

**线程栈**是每个线程独有的栈空间，用于存储线程的局部变量、函数调用信息等。

主线程使用进程栈，而其他线程使用单独分配的线程栈。

### 进程栈和线程栈有哪些主要区别？有哪些相同点？

区别：

- 位置：进程栈是内核创建进程时申请的，位于进程地址空间的栈段；线程栈是 glibc 申请的，内核不管，通常在堆中分配
- 分配方式：进程栈由内核自动分配；线程栈由线程库（如 pthread）分配
- 扩展性：进程栈可以动态扩展（直到限制）；线程栈大小通常固定
  - 进程栈创建时只有 4KB，可以伸缩（动态拓展）；线程栈一次性申请指定大小的空间，没有伸缩功能
  - 进程栈可以伸缩、线程栈不可以伸缩
    - golang 线程栈中是可以伸缩的，golang 运行时先分配小内存，不够用后，申请大内存，并复制数据过去。
- 大小限制：进程栈受系统栈限制（ulimit -s）；线程栈有独立的大小设置。（但都受 ulimit 的 stack size 限制）

相同：

- 进程栈和线程栈都受 ulimit 中 stack size 大小的限制。可见示例：`cd 第6章-进程如何使用内存 && make test1`
- 都用于存储局部变量、函数参数、返回地址
- 都采用 LIFO（后进先出）的数据结构
- 都向低地址方向增长
- 都有栈溢出的风险

### 进程栈的初始大小是多少？进程栈的大小限制是多少？这个限制可以调整吗？Linux 内核源码中哪个宏或参数控制默认大小？

Linux 进程的进程栈初始大小是 1 页，通常是 4KB。
Linux 系统默认栈大小限制通常为 8MB。
可通过 ulimit -s 查看当前限制，最大限制（软限制）。
可通过 ulimit -s <size> 临时调整。
可通过 ulimit -Hs 查看当前最大硬限制。

在 Linux 内核源码中，相关的宏定义包括：

```c
#define _STK_LIM        (8*1024*1024)   // 默认 8MB
```

### 当发生栈溢出后应用程序会发生什么？
### 线程栈可以动态拓展吗？为什么？
### 线程为何要在用户空间申请栈内存？
### 默认的线程栈空间是多大？如果设置了 rlimit 但是超过 32MB，那么会是多少？


### 线程栈中都存储了哪些内容？不同的分配器对于线程栈存储的内容都是一样的吗？使用方式都一样吗？

存储内容：

- struct pthread 结构体
- 运行栈


### 程序申请内存后使用内存和内核从硬盘加载 elf 文件的内容到内存，都是通过缺页中断来处理的吗？

是的。缺页中断有不同的类型。

**1. Minor Page Fault（次缺页中断）**

- 场景：页面在内存中，但页表项未建立
- 处理：只需更新页表，不需要磁盘 I/O
- 例子：malloc 后首次访问

**2. Major Page Fault（主缺页中断）**

- 场景：页面不在内存中，需要从磁盘读取
- 处理：需要磁盘 I/O 操作
- 例子：访问被换出的页面，或首次访问文件映射的页面

场景汇总：

| 场景 | 是否使用缺页中断 | 时机 | 类型 |
|------|------------------|------|------|
| malloc/new 申请内存 | **是** | 首次访问时 | Minor Fault |
| ELF 文件加载 | **部分是** | 取决于访问模式 | Minor/Major Fault |
| 文件 mmap | **是** | 首次访问时 | Major Fault |
| 匿名 mmap | **是** | 首次访问时 | Minor Fault |
| 静态变量 | **可能** | 程序启动时可能预加载 | Minor Fault |
