# 第十二章 容器的内存资源限制

## 问题

- 容器内存限制在底层是如何实现的，传说中的 mem cgroup 长什么样？
- 如何正确查看容器的内存开销，其中 RSS、PageCache 开销又有什么差别？
- 容器中进程何时会被 OOM Kill？我们是否有办法避免进程被操作系统杀死？
- 设置 cgroup 内存限制 memory.limit_in_bytes，最小可以是多少？最大呢？

## 解答

### 容器内存限制在底层是如何实现的，传说中的 mem cgroup 长什么样？

通过 mem cgroup 实现。本章相关的字段是：memcg->memory->usage、memcg->vmstats_percpu->state[] 等。
缺页中断分配物理内存时，会将容器的用量记录到 memcg->memory->usage，将它和用户设置的限制对比。
如果超出，会触发对 PageCache 等内存的回收，如果回收后还是超出，则可能会触发 OOM Kill，导致用户进程被杀死。

> mem_cgroup 结构在 include/linux/memcontrol.h 文件中

```c
/*
 * 内存控制器数据结构。
 * 内存控制器控制每个控制组（cgroup）的页缓存和驻留集大小（RSS）。
 * 我们最终希望基于 Rik Van Riel 为 clock-pro 开发的统计信息来提供相关统计数据，以帮助管理员确定需要调整哪些控制旋钮。
 */
struct mem_cgroup {
	struct cgroup_subsys_state css;

	/* Private memcg ID. Used to ID objects that outlive the cgroup */
	struct mem_cgroup_id id;

	/* Accounted resources */
	struct page_counter memory;		/* Both v1 & v2 */

    //...

	struct memcg_vmstats_percpu __percpu *vmstats_percpu;

    // ...
};
```

### 如何正确查看容器的内存开销，其中 RSS、PageCache 开销又有什么差别？

推荐使用 memory.stat：`cat /sys/fs/cgroup/memory/<cgroup_name>/memory.stat`

- rss (Resident Set Size)：进程实际占用的物理内存（匿名页），包括堆、栈等，**不可回收**
- cache (Page Cache)：文件缓存和共享内存，**可被内核回收**
- total_rss：总 RSS 内存（包含所有子 cgroup）
- total_cache：总缓存内存

核心区别：RSS 是真实内存开销，Cache 在内存紧张时可释放。

### 容器中进程何时会被 OOM Kill？我们是否有办法避免进程被操作系统杀死？

容器中进程出现内存不足时，会先尝试对 Page Cache 进行回收，回收后还不足，才可能出现 OOM Kill。

具体 OOM Kill 触发条件：

- cgroup 内存使用达到 memory.limit_in_bytes 限制
- 内核先尝试回收 Page Cache
- 回收后仍不足，触发 OOM Killer，选择 oom_score 最高的进程杀死

如果进程启动非常耗时，不希望被杀死，可以通过修改 memory.oom_control 来干预内核的行为。虽然进程无法继续运行，但是当有容器内其他进程释放内存，进程可以继续运行。

避免被杀死的方法：

- 禁用 OOM Killer：`echo 1 > /sys/fs/cgroup/memory/<cgroup_name>/memory.oom_control`
- 调整 OOM 优先级：`echo -1000 > /proc/<pid>/oom_score_adj`，降低被杀概率（-1000 到 1000）
- 增加内存限制（治本）：`echo 2G > /sys/fs/cgroup/memory/<cgroup_name>/memory.limit_in_bytes`

最佳实践：合理设置内存限制 + 监控内存使用，而非依赖禁用 OOM。

实践/示例：`make -C ./第12章-容器的内存资源限制 test1`

### 设置 cgroup 内存限制 memory.limit_in_bytes，最小可以是多少？最大呢？

最小值：
- 4KB（4096 字节） - 理论最小值（一个页面大小）
- 实际上内核会向上对齐到**页面大小的整数倍**（通常是 4KB）、忽略、或重置为 0，我的测试系统中实际的行为是重置为 0
- 设置过小会导致进程立即 OOM，实际**建议最小值 ≥ 几 MB**

最大值：
- 理论上：`2^63 - 1` 字节（约 8 EB）
- 实际上：受物理内存 + swap 总量限制
- 设置为 `-1` 表示**不限制**（无限大）

实践/示例：`make -C ./第12章-容器的内存资源限制 test2`
