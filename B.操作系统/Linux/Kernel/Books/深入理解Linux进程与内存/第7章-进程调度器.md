# 进程调度器

## 问题

- 调度器的发展过程？
  - 无论是什么调度算法，都是围绕以下两个问题：
    - CPU 如何选择下面让哪一个任务执行？
    - 允许选中的进程运行多长的时间？
- 进程不主动释放 CPU 的话，每次调度最少能运行多久？最多能运行多久？
- 现在的进程调度还是按时间片来执行的吗？
- 进程的 nice 值的含义是什么？
- 在用户进程中，高优先级是否能抢占低优先级的 CPU？
- 业界流行的在离线混部有没有副作用？
- 为什么进程会在 CPU 各个核之间飘来飘去？
- taskset 命令是如何让一个进程钉在某个核上的？


## 总结

### 调度器的发展过程？

> 无论是什么调度算法，都是围绕以下两个问题：
>   - CPU 如何选择下面让哪一个任务执行？
>   - 允许选中的进程运行多长的时间？

先进先出：任务都加入到一个队列中，先来先服务。问题：短时任务需等待长时任务完成，系统整体的响应能力非常差。
->
短作业优先：先评估处理所需的耗时，再进行处理，时间短的优先处理。问题：不公平，长作业可能一直得不到执行。
->
时间片轮转：开始考虑公平性，每个任务都指定固定的时间，时间到执行下一个任务，任务未完成就继续进入等待队列。问题：“太公平”，耗时少的紧急任务无法优先处理。
->
Linux 2.4 O(n) 调度器：同时加入动态和静态优先级，根据静态优先级和任务执行情况，计算动态优先级，避免短作业优先算法的长时任务饿死问题和时间片轮转算法中的问题。
随着 CPU 硬件在单核主频上受到物理极限限制，CPU 开始朝着多核发展，O(n) 调度器出现问题：单任务队列，锁竞争严重；O(n) 遍历方式也低效。
->
Linux 2.5 O(1) 调度器：采用多优先级（0-139 级）任务队列，同时引入 bitmap 辅助实现 O(1) 查找。
  - 优先级 0-99 给实时进程，实时进程只有静态优先级，优先级高的进程拥有绝对的优先权，并且能抢占低优先级进程的 CPU 时间。
  - 优先级 100-140 给普通进程
-> 完全公平调度器：TODO

### 进程不主动释放 CPU 的话，每次调度最少能运行多久？最多能运行多久？

Linux 内核 2.5.68 中，有以下定义：

```c
#define MIN_TIMESLICE (10 * HZ / 1000)
#define MAX_TIMESLICE (200 * HZ / 1000)
```

也就是最小时间片是 `10 * HZ / 100`，最大时间片是 `200 * HZ / 1000`。
`HZ` 代表时钟中断的次数，不是实际的时间单位，通过 `jiffies_to_time*` 相关函数转换成时间。上面两个值分别是 `10,000us(10ms)` 和 `200,000us(200ms)`。
优先级越高获得的时间片越多。
