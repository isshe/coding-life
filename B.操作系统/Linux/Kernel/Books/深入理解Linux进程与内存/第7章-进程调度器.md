# 进程调度器

## 问题

- 调度器的发展过程？
  - 无论是什么调度算法，都是围绕以下两个问题：
    - CPU 如何选择下面让哪一个任务执行？
    - 允许选中的进程运行多长的时间？
- 进程不主动释放 CPU 的话，每次调度最少能运行多久？最多能运行多久？
- 现在的进程调度还是按时间片来执行的吗？
- 进程的 nice 值的含义是什么？
- 在用户进程中，高优先级是否能抢占低优先级的 CPU？
- 业界流行的在离线混部有没有副作用？
- 为什么进程会在 CPU 各个核之间飘来飘去？
- taskset 命令是如何让一个进程钉在某个核上的？
- 最新内核或 5.14 及之后的调度器是什么类型的？相关的代码或宏定义有哪些？（SCHED_RR...）
- 实时进程和普通用户进程是怎么区分的？内核是如何知道的？是内核自行识别的吗？


## 总结

### 调度器的发展过程？

> 无论是什么调度算法，都是围绕以下两个问题：
>   - CPU 如何选择下面让哪一个任务执行？
>   - 允许选中的进程运行多长的时间？

先进先出：任务都加入到一个队列中，先来先服务。问题：短时任务需等待长时任务完成，系统整体的响应能力非常差。
->
短作业优先：先评估处理所需的耗时，再进行处理，时间短的优先处理。问题：不公平，长作业可能一直得不到执行。
->
时间片轮转：开始考虑公平性，每个任务都指定固定的时间，时间到执行下一个任务，任务未完成就继续进入等待队列。问题：“太公平”，耗时少的紧急任务无法优先处理。
->
Linux 2.4 O(n) 调度器：同时加入动态和静态优先级，根据静态优先级和任务执行情况，计算动态优先级，避免短作业优先算法的长时任务饿死问题和时间片轮转算法中的问题。
随着 CPU 硬件在单核主频上受到物理极限限制，CPU 开始朝着多核发展，O(n) 调度器出现问题：单任务队列，锁竞争严重；O(n) 遍历方式也低效。
->
Linux 2.5 O(1) 调度器：采用多优先级（0-139 级）任务队列，同时引入 bitmap 辅助实现 O(1) 查找。
  - 优先级 0-99 给实时进程，实时进程只有静态优先级，优先级高的进程拥有绝对的优先权，并且能抢占低优先级进程的 CPU 时间。
  - 优先级 100-140 给普通进程
-> 完全公平调度器：TODO
  - 精髓：对于 N 个进程的系统，在时间周期 T 内，每个进程运行 T/N 的时间。
  - 摒弃了固定时间片的思路，根据当前系统的情况动态计算调度周期。
  - 但绝对公平是不现实的，有的进程可能确实需要更多的 CPU，所以实际上分配是按比例来的，比例是由优先级决定的。

### 进程不主动释放 CPU 的话，每次调度最少能运行多久？最多能运行多久？

Linux 内核 2.5.68 中，有以下定义：

```c
#define MIN_TIMESLICE (10 * HZ / 1000)
#define MAX_TIMESLICE (200 * HZ / 1000)
```

也就是最小时间片是 `10 * HZ / 100`，最大时间片是 `200 * HZ / 1000`。
`HZ` 代表时钟中断的次数，不是实际的时间单位，通过 `jiffies_to_time*` 相关函数转换成时间。上面两个值分别是 `10,000us(10ms)` 和 `200,000us(200ms)`。
优先级越高获得的时间片越多。


### 实时进程和普通用户进程是怎么区分的？内核是如何知道的？是内核自行识别的吗？

通过 `task_struct` 的 `policy` 字段识别。

`policy` 取值：（TODO 到内核源码中确认）

- SCHED_NORMAL：非实时，普通进程（也叫 SCHED_OTHER）
- SCHED_BATCH：非实时，批处理任务
- SCHED_IDLE：非实时，最低优先级任务（几乎闲时才运行）
- SCHED_FIFO：实时，先到先服务的实时任务
- SCHED_RR：实时，时间片轮转的实时任务
- SCHED_DEADLINE：实时，基于截止时间的实时任务（EDF）

不是内核自行识别的。是进程（程序/线程）自己主动设置或外部（系统管理员、调度器、服务管理器等）手动设置。

TODO：更多
