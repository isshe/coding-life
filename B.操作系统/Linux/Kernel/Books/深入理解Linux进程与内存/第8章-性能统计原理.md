# 第八章 性能统计原理

## 问题

- CPU 关键的性能指标有哪些？
- 都有哪些进程状态？
- 负载是如何计算出来的？
- top 命令中的平均负载（过去 1/5/15 分钟平均负载）是怎么得到的？
- 负载高低和 CPU 消耗正相关吗？
- 什么情况下进程会是 uninterruptible 状态呢？
- 内核是如何给应用层暴露负载数据的？
- top 命令中负载计算是通过时间差来计算的，那么运行 top 首次展示的数据是什么数据呢？
- top 输出的利用率信息是如何计算出来的，它精确吗？
- CPU 利用率信息统计数据类型
- top 输出中 ni 列代表的是 nice，它输出的是 CPU 在处理什么时的开销？
- top 输出中 wa 列代表的是 iowait，那么这段时间 CPU 到底是忙碌还是空闲？
- 什么是 CPI、IPC？
- 在性能观测中为什么 CPI 指标非常重要？
- 评估 CPI/IPC 的工具？
- 降低 CPI 的方法？
- CPI 数值参考

## 总结

### CPU 关键的性能指标有哪些？

1. **负载**：系统繁忙程度
2. **CPU 利用率**：CPU 时间分配情况
3. **CPI**（Cycles Per Instruction）：指令执行效率

### 都有哪些进程状态？

```
R (running)      - TASK_RUNNING          - 运行或就绪
S (sleeping)     - TASK_INTERRUPTIBLE    - 可中断睡眠
D (disk sleep)   - TASK_UNINTERRUPTIBLE  - 不可中断睡眠
T (stopped)      - __TASK_STOPPED        - 停止
t (tracing stop) - __TASK_TRACED         - 调试停止
Z (zombie)       - EXIT_ZOMBIE           - 僵尸进程
X (dead)         - EXIT_DEAD             - 死亡
P (parked)       - TASK_PARKED           - 暂停
I (idle)         - TASK_IDLE             - 空闲
```

### 负载是如何计算出来的？

1. **瞬时负载**：统计所有 CPU 运行队列中 R（TASK_RUNNING）和 D（TASK_INTERRUPTIBLE）状态进程数量
2. **平均负载**：使用指数加权移动平均法（Exponential Weighted Moving Average,EWMA）计算 1/5/15 分钟平均值
3. **实现位置**：内核函数 `calc_global_load`

### top 命令中的平均负载（过去 1/5/15 分钟平均负载）是怎么得到的？

读取 `/proc/loadavg` 文件获取，对应内核源码 `fs/proc/loadavg.c`。

### 负载高低和 CPU 消耗正相关吗？

**不一定**。负载包含 D 状态进程（等待 I/O，不消耗 CPU），因此负载反映的是整体系统繁忙程度，而非单纯 CPU 使用率。

### 什么情况下进程会是 uninterruptible 状态呢？

进程执行不可中断的关键操作时：（注：可以通过在源码中搜索 TASK_UNINTERRUPTIBLE 看哪些情况会导致 TASK_UNINTERRUPTIBLE 状态）
- 磁盘 I/O 操作
- 网络 I/O 等待
- 内存管理操作
- 设备驱动调用
- 文件系统同步

### 内核是如何给应用层暴露负载数据的？

通过 `/proc` 伪文件系统：
- `/proc/loadavg` - 负载信息
- `/proc/stat` - CPU 统计信息
- `/proc/{PID}/stat` - 进程统计信息

### top 命令中负载计算是通过时间差来计算的，那么运行 top 首次展示的数据是什么数据呢？

**系统启动以来的累计平均值**，而非瞬时值。

### top 输出的利用率信息是如何计算出来的，它精确吗？

**计算方式**：
- 内核通过 timer interrupt（CONFIG_HZ 定义频率）周期性采样
- 每次中断调用 `update_process_times` 更新 `kernel_cpustat` 数组
- top 读取 `/proc/stat` 获取数据

**精确性**：基于采样统计，非 100% 精确，但足够反映系统状态。

### CPU 利用率信息统计数据类型
- 用户态时间：user、nice
- 内核态时间：hardware irq、software irq、system
- 空闲时间：iowait、idle

相关代码见 `update_process_times`、`account_process_tick`。

### top 输出中 ni 列代表的是 nice，它输出的是 CPU 在处理什么时的开销？

**nice 值 > 0 的进程在用户态的 CPU 时间**。

注意：总用户态时间 = user + nice

### top 输出中 wa 列代表的是 iowait，那么这段时间 CPU 到底是忙碌还是空闲？

**空闲** —— CPU 空闲中，但是有进程正在等待 I/O 完成。
iowait 是空闲时间的一种分类，表示 CPU 空闲且有进程等待 I/O。如有其他进程需要 CPU，会立即获得。

### 什么是 CPI、IPC？

- **CPI**（Cycles Per Instruction）：每条指令平均需要的时钟周期数
- **IPC**（Instructions Per Cycle）：每个时钟周期平均执行的指令数

关系：CPI = 1/IPC

### 在性能观测中为什么 CPI 指标非常重要？

CPI 直接反映 CPU 执行效率：
- **低 CPI**：指令执行效率高，缓存命中率好，分支预测准确
- **高 CPI**：存在性能瓶颈，需要优化
- **指导优化**：帮助识别缓存、流水线等性能问题

### 评估 CPI/IPC 的工具？

```bash
sudo perf stat <PROGRAM>
# 例如：sudo perf stat ls
```

### 降低 CPI 的方法？

**硬件**：
- 更高频率内存
- 更大 CPU 缓存

**软件**：
- 编写缓存友好代码
- 使用 taskset 绑定 CPU 核心
- 选择寄存器传参语言（如 C）
- 合理配置容器资源

### CPI 数值参考

**简单标准**：CPI < 2 良好，CPI > 4 需优化

**详细参考**：
- **< 1.0**：优秀（超级标量处理器理想状态）
- **0.5-1.5**：良好（现代 CPU 典型表现）
- **1.5-3.0**：一般（存在轻微瓶颈）
- **3.0-5.0**：较差（明显性能问题）
- **> 5.0**：严重（需重点优化）
