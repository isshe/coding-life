# 第 4 章 进程加载启动原理

## 问题

- segment 和 session 的概念？分别是什么？如何通过命令查看？
- 加载可执行文件头时，是读取了 128 字节还是 256 字节？
- 为何可执行文件的加载器用 list 而不用 hash？每次加载二进制文件查找加载器时，都需遍历列表？
- 如果程序特别大，加载不完怎么处理的？除了有 LOAD 标记的 segment 被加载，还有哪会被加载？
- INTERP Segment 是什么？为何动态链接器入口地址可以作为程序入口地址？
- Shell 是如何将程序执行起来的？（也就是程序启动流程）
- 编译链接后生成的可执行程序长什么样子？
- 程序启动后，如何查看进程的各个 Segment？
- Shell 实际是用 fork 来创建进程吗？为什么？

TODO

## 总结

### segment 和 session 的概念？分别是什么？

答：segment 由相同权限的一个或多个 session 组成，以便操作系统更快地加载。
    通过 `readelf -l /path/to/bin` 或 `-a` 等选项都可以查看。

### 加载可执行文件头时，是读取了 128 字节还是 256 字节？

答：BINPRM_BUF_SIZE 从 Linux 5.1 开始，从 128 变更成了 256 字节。
    链接：https://lore.kernel.org/all/20181112160956.GA28472@redhat.com/T/#u
    Commit ID：6eb3c3d0a52dca337e327ae8868ca1f44a712e02

### 为何可执行文件的加载器用 list 而不用 hash？每次加载二进制文件查找加载器时，都需遍历列表？

答：

1. ​加载器数量极少​​，遍历开销可忽略。
1. 需要维护匹配顺序​​（如脚本优先于 ELF）。
1. 动态注册/卸载的灵活性​​。
1. 代码简洁性​​，避免哈希表的复杂性。

这种设计在保持高效的同时，完美满足了内核的需求。
哈希表虽然理论复杂度更低，但在实际场景中并无优势。

### 如果程序特别大，加载不完怎么处理的？除了有 LOAD 标记的 segment 被加载，还有哪会被加载？

答：除了 LOAD 段，还有以下段可能被处理/加载：
- PT_DYNAMIC - 动态链接器会读取这个段来获取动态链接信息
- PT_INTERP - 内核读取此段获取动态链接器路径
- PT_TLS - 线程局部存储会被加载到特定区域
- PT_GNU_EH_FRAME - 异常处理时会被访问

加载时，通常是只加载入口所在页，然后通过缺页中断，加载后续的页。也就是 LOAD 的段，不会已启动就加载。

验证方法：TODO

1. 查看程序入口点

```
readelf -h your_binary | grep Entry
```

1. 监控页面错误

```
strace -e trace=mmap,mprotect,brk ./your_program
```

1. 查看内存映射（启动程序后立即查看）

```
cat /proc/PID/maps
```
