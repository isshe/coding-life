# 第 4 章 进程加载启动原理

## 问题

- segment 和 session 的概念？分别是什么？如何通过命令查看？
- 加载可执行文件头时，是读取了 128 字节还是 256 字节？
- 为何可执行文件的加载器用 list 而不用 hash？每次加载二进制文件查找加载器时，都需遍历列表？
- 如果程序特别大，加载不完怎么处理的？除了有 LOAD 标记的 segment 被加载，还有哪会被加载？
- INTERP Segment 是什么？为何动态链接器入口地址可以作为程序入口地址？
- Shell 是如何将程序执行起来的？（也就是程序启动流程）
- 编译链接后生成的可执行程序长什么样子？
- 程序启动后，如何查看进程的各个 Segment？
- Shell 实际是用 fork 来创建进程吗？为什么？

## 总结

### segment 和 session 的概念？分别是什么？如何通过命令查看？

segment 由相同权限的一个或多个 session 组成，以便操作系统更快地加载。
通过 `readelf -l /path/to/bin` 或 `-a` 等选项都可以查看。

### 加载可执行文件头时，是读取了 128 字节还是 256 字节？

BINPRM_BUF_SIZE 从 Linux 5.1 开始，从 128 变更成了 256 字节。
链接：https://lore.kernel.org/all/20181112160956.GA28472@redhat.com/T/#u
Commit ID：6eb3c3d0a52dca337e327ae8868ca1f44a712e02

### 为何可执行文件的加载器用 list 而不用 hash？每次加载二进制文件查找加载器时，都需遍历列表？

答：

1. ​加载器数量极少​​，遍历开销可忽略。
1. 需要维护匹配顺序​​（如脚本优先于 ELF）。
1. 动态注册/卸载的灵活性​​。
1. 代码简洁性​​，避免哈希表的复杂性。

这种设计在保持高效的同时，完美满足了内核的需求。
哈希表虽然理论复杂度更低，但在实际场景中并无优势。

### 编译链接后生成的可执行程序长什么样子？ELF 文件格式是怎样的？除了头部，剩下的是什么？

格式如下：

```
+-------------------+
| ELF Header        | <- 64字节(64位) 或 52字节(32位)
+-------------------+
| Program Headers   | <- 可选，用于执行
+-------------------+
| Section 1         |
+-------------------+
| Section 2         |
+-------------------+
| ...               |
+-------------------+
| Section Headers   | <- 用于链接和调试
+-------------------+
```

通过 Program Headers（就是 segment）定位到各个 segment。

更多：

- ELF 相关内核结构见：[Linux 内核数据结构 —— ELF 相关结构](B.操作系统/Linux/Kernel/2.数据结构/elf.md)


### 如果 Linux 可执行文件特别大，加载不完怎么处理的？除了有 LOAD 标记的 segment 被加载，还有哪会被加载？

答：

当 Linux 可执行文件特别大时，系统采用**按需分页（demand paging）**机制：

- 初始加载：只加载必要的页面到内存
- 缺页中断：访问未加载页面时触发 page fault
- 动态加载：从文件中读取需要的页面到内存
- 页面置换：内存不足时将不常用页面换出

除了 LOAD 段，还有以下段可能被处理/加载：
- PT_DYNAMIC - 动态链接器会读取这个段来获取动态链接信息
- PT_INTERP - 内核读取此段获取动态链接器路径
- PT_TLS - 线程局部存储会被加载到特定区域
- PT_GNU_EH_FRAME - 异常处理时会被访问

加载时，通常是只加载入口所在页，然后通过缺页中断，加载后续的页。也就是 LOAD 的段，不会一启动就加载。

验证方法：TODO

1. 查看程序入口点

```
readelf -h your_binary | grep Entry
```

1. 监控页面错误

```
strace -e trace=mmap,mprotect,brk ./your_program
```

1. 查看内存映射（启动程序后立即查看）

```
cat /proc/PID/maps
```

### INTERP Segment 是什么？为何动态链接器入口地址可以作为程序入口地址？程序的入口是我们熟知的 amin 函数吗？

TODO

### Shell 是如何将程序执行起来的？

答：

- Shell 进程通过 fork + execve 加载并运行新进程
- 内核读取并解析 ELF 头，获取程序头表位置
- 读取程序头表 Program Header Table
- 清空父进程集成来的资源，使用新的 mm_struct 和新的栈
- 遍历程序头表，找到所有 LOAD 类型的段（Program Header），加载到内存中（下面 p_xxx 是段 Elf64_Phdr 的结构成员）
  - 为每个段分配虚拟内存，地址由 p_vaddr 指定
  - 从文件偏移 p_offset 处读取 p_filesz 字节到虚拟地址 p_vaddr
  - 如果 p_memsz > p_filesz，剩余部分用零填充（如 BSS 段）
- 计算并跳转到程序入口执行

### 程序启动后，如何查看进程的各个 Segment？

TODO

### Shell 实际是用 fork 来创建进程吗？为什么？

TODO
