# 第 4 章 进程加载启动原理

## 问题

- segment 和 section 的概念？分别是什么？如何通过命令查看？
- 加载可执行文件头时，是读取了 128 字节还是 256 字节？
- 为何可执行文件的加载器用 list 而不用 hash？每次加载二进制文件查找加载器时，都需遍历列表？
- 如果程序特别大，加载不完怎么处理的？除了有 LOAD 标记的 segment 被加载，还有哪会被加载？
- INTERP Segment 是什么？为何动态链接器入口地址可以作为程序入口地址？
- Shell 是如何将程序执行起来的？（也就是程序启动流程）
- 编译链接后生成的可执行程序长什么样子？
- 程序启动后，如何查看进程的各个 Segment？
- Shell 实际是用 fork 来创建进程吗？为什么？

## 总结

### segment 和 section 的概念？分别是什么？如何通过命令查看？

segment 由相同权限的一个或多个 section 组成，以便操作系统更快地加载。
通过 `readelf -l /path/to/bin` 或 `-a` 等选项都可以查看。

### 加载可执行文件头时，是读取了 128 字节还是 256 字节？

BINPRM_BUF_SIZE 从 Linux 5.1 开始，从 128 变更成了 256 字节。
链接：https://lore.kernel.org/all/20181112160956.GA28472@redhat.com/T/#u
Commit ID：6eb3c3d0a52dca337e327ae8868ca1f44a712e02

### 为何可执行文件的加载器用 list 而不用 hash？每次加载二进制文件查找加载器时，都需遍历列表？

答：

1. ​加载器数量极少​​，遍历开销可忽略。
1. 需要维护匹配顺序​​（如脚本优先于 ELF）。
1. 动态注册/卸载的灵活性​​。
1. 代码简洁性​​，避免哈希表的复杂性。

这种设计在保持高效的同时，完美满足了内核的需求。
哈希表虽然理论复杂度更低，但在实际场景中并无优势。

### 编译链接后生成的可执行程序长什么样子？ELF 文件格式是怎样的？除了头部，剩下的是什么？

格式如下：

```
+-------------------+
| ELF Header        | <- 64字节(64位) 或 52字节(32位)
+-------------------+
| Program Headers   | <- 可选，用于执行
+-------------------+
| Section 1         |
+-------------------+
| Section 2         |
+-------------------+
| ...               |
+-------------------+
| Section Headers   | <- 用于链接和调试
+-------------------+
```

通过 Program Headers（就是 segment）定位到各个 segment。

更多：

- ELF 相关内核结构见：[Linux 内核数据结构 —— ELF 相关结构](B.操作系统/Linux/Kernel/2.数据结构/elf.md)


### 如果 Linux 可执行文件特别大，加载不完怎么处理的？除了有 LOAD 标记的 segment 被加载，还有哪会被加载？

答：

当 Linux 可执行文件特别大时，系统采用**按需分页（demand paging）**机制：

- 初始加载：只加载必要的页面到内存
- 缺页中断：访问未加载页面时触发 page fault
- 动态加载：从文件中读取需要的页面到内存
- 页面置换：内存不足时将不常用页面换出

除了 LOAD 段，还有以下段可能被处理/加载：
- PT_DYNAMIC - 动态链接器会读取这个段来获取动态链接信息
- PT_INTERP - 内核读取此段获取动态链接器路径
- PT_TLS - 线程局部存储会被加载到特定区域
- PT_GNU_EH_FRAME - 异常处理时会被访问

加载时，通常是只加载入口所在页，然后通过缺页中断，加载后续的页。也就是 LOAD 的段，不会一启动就加载。

验证方法：TODO

1. 查看程序入口点

```
readelf -h your_binary | grep Entry
```

1. 监控页面错误

```
strace -e trace=mmap,mprotect,brk ./your_program
```

1. 查看内存映射（启动程序后立即查看）

```
cat /proc/PID/maps
```

### INTERP Segment 是什么？

INTERP Segment（解释器段）是 ELF 文件中的一个特殊段，它包含了动态链接器的路径。这个段告诉内核在加载程序时应该使用哪个动态链接器来处理这个可执行文件。

查看 INTERP 段内容：

```bash
readelf -l /bin/ls | grep INTERP -A 2
```

典型的 INTERP 段内容是：/lib64/ld-linux-x86-64.so.2

### 为何动态链接器（ld）入口地址可以作为程序入口地址？为何要这么实现？

准确的说法是：当程序需要动态链接时，内核将控制权交给动态链接器。Linux 内核先加载和 elf 文件，看是否有 INTERP 段，有就说明是动态链接，需要将控制权交给动态链接器。
动态链接器再调用实际的程序入口。相当于在程序入口前，加了一道处理。**目的是实现动态链接。**动态链接有以下好处：

- 文件体积小
- 避免重复加载共享库的代码，降低内存占用，避免浪费
- 解耦以后，依赖库可另外更新，打安全补丁，提高安全性。
- 地址空间布局随机化（ASLR）

检查入口地址可以使用测试程序：

```bash
cd 第4章-进程加载启动原理/
make
```

### 程序的入口是我们熟知的 main 函数吗？

不是。

可以结合下面一个问题的启动流程一起看。以下流程主要是程序入口的视角：（**动态链接的程序，非静态链接的程序！**）

```bash
1. 内核 execve()
   ↓
2. 内核加载 ELF 文件，发现 INTERP 段
   ↓
3. 内核加载动态链接器 (ld-linux-x86-64.so.2)
   ↓
4. 内核将控制权交给动态链接器
   ↓
5. 动态链接器执行：
   - 加载所需共享库 (libc.so.6, 等)
   - 解析符号引用
   - 执行重定位
   - 跳转到程序的 _start
   ↓
6. _start 执行 (这时 libc.so.6 已经加载)
   ↓
7. _start 调用 __libc_start_main (来自已加载的 libc.so.6)
   ↓
8. __libc_start_main 初始化 C 运行时环境
   ↓
9. __libc_start_main 调用 main()
```

**注意：__libc_start_main 是在 libc.so.6 中，不在动态链接器中。**

### Shell 是如何将程序执行起来的？

答：

可以结合上面一个问题的启动流程一起看。以下流程主要是 ELF 文件格式的视角：

- Shell 进程通过 fork + execve 加载并运行新进程
- 内核读取并解析 ELF 头，获取程序头表位置
- 读取程序头表 Program Header Table
- 清空父进程集成来的资源，使用新的 mm_struct 和新的栈
- 遍历程序头表，找到所有 LOAD 类型的段（Program Header），加载到内存中（下面 p_xxx 是段 Elf64_Phdr 的结构成员）
  - 为每个段分配虚拟内存，地址由 p_vaddr 指定
  - 从文件偏移 p_offset 处读取 p_filesz 字节到虚拟地址 p_vaddr
  - 如果 p_memsz > p_filesz，剩余部分用零填充（如 BSS 段）
- 计算并跳转到程序入口执行

### 程序启动后，如何查看进程的各个 Segment？

```bash
cat  /proc/PID/maps

pmap $PID

cat /proc/$PID/smaps
```

### Shell 实际是用 fork 来创建进程吗？为什么？

是的，Shell 主要使用 fork + exec 模式创建进程。

原因：进程隔离、环境继承、资源管理
例外：内置命令不 fork
优化：现代 shell 可能使用 vfork 或 posix_spawn
