
# select
select函数允许进程指示内核等待多个事件，并在有一个或多个时间或经历指定时间后唤醒进程。

## 1. select
```c
#include <sys/select.h>

 int select(int nfds, fd_set *restrict readfds, fd_set *restrict writefds,
         fd_set *restrict errorfds, struct timeval *restrict timeout);
```
* 作用：指示内核等待多个事件，并在有一个或多个时间或经历指定时间后唤醒进程。
* 参数：
    * nfds: 待测试的最大描述符+1；
    * readfds: 监听读的fd集合；
    * writefds: 监听写得fd集合；
    * errorfds: 监听异常的fd集合；
    * timeout: 等待超时时间。
        * NULL: 永远等下去；
        * 非NULL且不为值0: 等待指定时间；
        * 非NULL且值为0: 不等待，检查描述符后立即返回。（轮询）
* 返回：
* 返回：
    * 成功：就绪描述符数目
    * 超时：0
    * 出错：-1

## 2. 描述符就绪条件
* 读就绪：
    * 该套接字接收缓冲区的数据字节数`>=`套接字缓冲区`低水位标记`的当前大小。
        * 高于水位，认为可读。
    * 该套接字的读半部关闭(接收了FIN的TCP连接)。
        * 返回EOF
    * 该套接字是一个监听套接字且已完成的连接数不为0。
        * 此时accept通常不阻塞。
    * 其上有一个套接字错误待处理。
        * 读操作不阻塞、返回-1，并设置errno。
        * 待处理错误，可通过getsockoptvidkSO_ERROR套接字获取并清除。
* 写就绪：
    * 发送缓冲区的数据字节数`>=`套接字缓冲区低水位标记的当前大小。
    * 该连接的写半部关闭。
        * 此时写，会产生`SIGPIPE`信号。
    * 使用非阻塞connect的套接字已建立连接，或者connect已经以失败告终。
    * 其上有一个套接字错误待处理。
* 异常就绪：（？！）
    * 套接字存在带外数据或者仍处于带外标记。
        * 注意：当某个套接字上发生错误时，它将由select标记为`可读又可写`。
* 汇总：
|条件|可读吗？|可写吗？|异常吗？|
|---|---|---|---|
|有数据可读|+|||
|关闭连接的读一半|+|||
|给监听套接字准备好新连接|+|||
|有可用于写得空间||+||
|关闭连接的写一半||+||
|待处理错误|+|+||
|TCP带外数据|||+|

## 3. shutdown
终止网络连接的通常方法是close函数，但是close有两个限制：（可以用shutdown来避免）。
* close把描述符的引用计数-1，仅在计数为0时才关闭套接字。
* close终止读和写两个方向的数据传送。
```c
#include <sys/socket.h>

int shutdown(int sockfd, int howto);
```
* 作用：关闭网络连接。
* 参数：
    * howto:
        * SHUT_RD: 关闭连接的读一半。
        * SHUT_WR: 关闭连接的写一半。
        * SHUT_RDWR: 读写都关闭。（与调用两次shutdown等效。）

* 返回：
    * 成功：0
    * 失败：Exxx值

## A. 注意、拓展
* timeval结构允许指定微秒级的分辨率，然而内核支持的真实分辨率往往粗糙得多。
* timeval结构能支持select不支持的值。
* 如果select的三个fds都设置为NULL，则可以得到一个比sleep函数更为精确的定时器。
* 使用select的最常见错误：
    * 忘记对最大描述符+1；
    * 忘记描述符集是`值——结果`参数。
* 接收低水位标记和发送低水位标记的作用是什么？
    * 目的在于：允许应用进程控制在select返回可读/可写条件之前，有多少数据可读或有多大空间可用于写。
    * 例如：如果我们知道除非至少存在64字节数据，否则我们的应用程序无事可做，那么可以将接受低水位标记设置为64。防止过早唤醒。
* 任何UDP套接字只要其`发送低水位标记``<=`发送缓冲区大小，就总是可写的。（因为UDP不需要连接）
