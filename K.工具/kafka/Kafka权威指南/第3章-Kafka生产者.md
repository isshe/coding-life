[TOC]


第三章 Kafka 生产者——向 Kafka 写入数据
---

# 创建生产者
* bootstrap.servers: 指定 broker 的地址清单，地址格式为`host:port`。
* key.serializer: Key 序列化器。
    * 必须时限为一个实现了`org.apache.kafka.common.serialization.Serializer`接口的类。
* value.serializer: 值序列化器。

# 发送消息
* 同步发送
    * producer.send() 后返回一个 Future 对象；
    * 使用 Future 对象的 get() 方法等待 Kafka 的响应。
* 异步发送
    * 支持回调，以处理异常等。

# 生产者的配置
* acks: 指定必须要有多少个分区副本收到消息，生产者才会认为消息写入是成功的。
    * acks=0：生产者在写入消息后不会等待任何来自服务器的响应。
        * 如果服务器没收到消息，生产者无法感知，会导致消息丢失。
    * acks=1：只要集群的首领节点收到消息，就会返回服务器的成功响应。
        * 如果首领节点没收到消息 (如首领节点奔溃)，生产者会收到一个错误响应，生产者会重发消息。
        * 如果一个没有收到消息的节点成为新首领，消息还是会丢失。
    * acks=all: 所有参与复制的节点全部收到消息时，生产者才会收到服务器的成功响应。
* buffer.memory: 设置生产者内存缓冲区的大小。
    * 如果应用程序发送消息的速度超过发送到服务器的速度，则会导致缓冲区不足，send() 方法要么被阻塞，要么抛异常。
* compression.type: 指定消息发送给 broker 之前使用哪种压缩算法进行压缩。（默认不压缩）
    * 压缩算法：snappy/gzip/lz4。
* retries: 发送重试次数。
    * 默认情况下，每次重试之前间隔 100ms。可通过 retry.backoff.ms 进行修改。
    * 建议：在设置之前先测试恢复一个奔溃节点需要多少时间，让总的重试时间比 Kafka 集群从奔溃中恢复的时间长。
* batch.size: 指定一个批次可以使用的内存大小（字节）。
    * 不一定会等到批次满了才发送，所以批次设置很大，也不会造成延迟，但是会占用更多内存。
* linger.ms: 发送批次的等待时间；
    * 批次填满，或者等待时机到，就发送。
* client.id: 任意字符串，服务器用它来标识消息来源。